<!DOCTYPE html>
<html lang="ru">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>–ö–∞—Ä—Ç–∞ –º–∞—Ä—à—Ä—É—Ç–∞ - –ü—É—Ç–µ—à–µ—Å—Ç–≤–∏–µ –ø–æ –ù–æ—Ä–≤–µ–≥–∏–∏</title>
    <meta
      name="description"
      content="–ò–Ω—Ç–µ—Ä–∞–∫—Ç–∏–≤–Ω–∞—è –∫–∞—Ä—Ç–∞ –ø—É—Ç–µ—à–µ—Å—Ç–≤–∏—è –ø–æ –ù–æ—Ä–≤–µ–≥–∏–∏ —Å –º–∞—Ä—à—Ä—É—Ç–æ–º –∏ —Ç–æ—á–∫–∞–º–∏ –∏–Ω—Ç–µ—Ä–µ—Å–∞"
    />
    <meta name="author" content="Norway Trip Planner" />

    <!-- PWA Meta Tags -->
    <meta name="theme-color" content="#3b82f6" />
    <meta name="apple-mobile-web-app-capable" content="yes" />
    <meta name="apple-mobile-web-app-status-bar-style" content="default" />
    <meta name="apple-mobile-web-app-title" content="Norway Trip Map" />

    <!-- Favicon -->
    <link
      rel="icon"
      type="image/svg+xml"
      href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><text y='.9em' font-size='90'>üó∫Ô∏è</text></svg>"
    />

    <link rel="stylesheet" href="styles.css" />
    <style>
      body {
        margin: 0;
        padding: 0;
        height: 100vh;
        overflow: hidden;
        font-family: system-ui, -apple-system, sans-serif;
      }

      .map-container {
        height: 100vh;
        width: 100vw;
        position: relative;
      }

      #map {
        height: 100%;
        width: 100%;
      }

      /* Header */
      .header {
        position: fixed;
        top: 0;
        left: 0;
        right: 0;
        z-index: 1000;
        background: rgba(255, 255, 255, 0.95);
        backdrop-filter: blur(10px);
        border-bottom: 1px solid rgba(0, 0, 0, 0.1);
        padding: 0.75rem 1rem;
        display: flex;
        align-items: center;
        justify-content: space-between;
        box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
      }

      .header h1 {
        font-size: 1.5rem;
        font-weight: 700;
        color: #1f2937;
        margin: 0;
        display: flex;
        align-items: center;
        gap: 0.5rem;
      }

      .header .nav-link {
        background: #3b82f6;
        color: white;
        padding: 0.5rem 1rem;
        border-radius: 6px;
        text-decoration: none;
        font-weight: 500;
        font-size: 0.9rem;
        transition: all 0.2s;
      }

      .header .nav-link:hover {
        background: #2563eb;
        transform: translateY(-1px);
      }

      /* Controls Panel */
      .controls-panel {
        position: fixed;
        top: 80px;
        left: 1rem;
        z-index: 999;
        background: rgba(255, 255, 255, 0.95);
        backdrop-filter: blur(10px);
        border-radius: 12px;
        padding: 1rem;
        box-shadow: 0 4px 20px rgba(0, 0, 0, 0.15);
        border: 1px solid rgba(0, 0, 0, 0.1);
        max-width: 280px;
        max-height: calc(100vh - 100px);
        overflow-y: auto;
      }

      .control-section {
        margin-bottom: 1.5rem;
      }

      .control-section:last-child {
        margin-bottom: 0;
      }

      .control-title {
        font-size: 0.9rem;
        font-weight: 600;
        color: #374151;
        margin-bottom: 0.75rem;
        display: flex;
        align-items: center;
        gap: 0.5rem;
      }

      .day-controls {
        display: grid;
        grid-template-columns: 1fr 1fr;
        gap: 0.5rem;
      }

      .day-button {
        padding: 0.5rem 0.75rem;
        border: 2px solid #3b82f6;
        background: white;
        color: #3b82f6;
        border-radius: 6px;
        cursor: pointer;
        font-weight: 500;
        font-size: 0.8rem;
        transition: all 0.2s;
        text-align: center;
      }

      .day-button:hover {
        background: #3b82f6;
        color: white;
      }

      .day-button.active {
        background: #3b82f6;
        color: white;
      }

      .filter-controls {
        display: grid;
        grid-template-columns: 1fr;
        gap: 0.4rem;
      }

      .filter-btn {
        padding: 0.4rem 0.6rem;
        border: 1.5px solid;
        background: white;
        border-radius: 5px;
        cursor: pointer;
        font-size: 0.75rem;
        font-weight: 500;
        transition: all 0.2s;
        text-align: center;
      }

      .filter-btn.btn-all {
        border-color: #6b7280;
        color: #6b7280;
      }
      .filter-btn.btn-logistics {
        border-color: #8b5cf6;
        color: #8b5cf6;
      }
      .filter-btn.btn-shopping {
        border-color: #f59e0b;
        color: #f59e0b;
      }
      .filter-btn.btn-accommodation {
        border-color: #10b981;
        color: #10b981;
      }
      .filter-btn.btn-activity {
        border-color: #ef4444;
        color: #ef4444;
      }
      .filter-btn.btn-sightseeing {
        border-color: #3b82f6;
        color: #3b82f6;
      }
      .filter-btn.btn-transport {
        border-color: #6b7280;
        color: #6b7280;
      }
      .filter-btn.btn-hidden_gem {
        border-color: #ec4899;
        color: #ec4899;
      }
      .filter-btn.btn-optional {
        border-color: #f97316;
        color: #f97316;
      }

      .filter-btn:hover,
      .filter-btn.active {
        color: white;
      }
      .filter-btn.btn-all:hover,
      .filter-btn.btn-all.active {
        background: #6b7280;
      }
      .filter-btn.btn-logistics:hover,
      .filter-btn.btn-logistics.active {
        background: #8b5cf6;
      }
      .filter-btn.btn-shopping:hover,
      .filter-btn.btn-shopping.active {
        background: #f59e0b;
      }
      .filter-btn.btn-accommodation:hover,
      .filter-btn.btn-accommodation.active {
        background: #10b981;
      }
      .filter-btn.btn-activity:hover,
      .filter-btn.btn-activity.active {
        background: #ef4444;
      }
      .filter-btn.btn-sightseeing:hover,
      .filter-btn.btn-sightseeing.active {
        background: #3b82f6;
      }
      .filter-btn.btn-transport:hover,
      .filter-btn.btn-transport.active {
        background: #6b7280;
      }
      .filter-btn.btn-hidden_gem:hover,
      .filter-btn.btn-hidden_gem.active {
        background: #ec4899;
      }
      .filter-btn.btn-optional:hover,
      .filter-btn.btn-optional.active {
        background: #f97316;
      }

      /* Route Options */
      .route-options {
        display: grid;
        gap: 0.5rem;
      }

      .route-option {
        display: flex;
        align-items: center;
        gap: 0.5rem;
        cursor: pointer;
        padding: 0.5rem;
        background: #f8fafc;
        border-radius: 6px;
        border: 1px solid rgba(0, 0, 0, 0.05);
        transition: all 0.2s;
      }

      .route-option:hover {
        background: #f1f5f9;
      }

      .route-option input[type="checkbox"] {
        width: 16px;
        height: 16px;
        accent-color: #3b82f6;
      }

      .route-option-text {
        font-size: 0.75rem;
        color: #374151;
        font-weight: 500;
      }

      /* Stats */
      .stats-section {
        display: grid;
        grid-template-columns: 1fr 1fr;
        gap: 0.5rem;
      }

      .stat-card {
        background: #f8fafc;
        padding: 0.75rem;
        border-radius: 6px;
        text-align: center;
        border: 1px solid rgba(0, 0, 0, 0.05);
      }

      .stat-number {
        font-size: 1.25rem;
        font-weight: 700;
        color: #3b82f6;
        margin-bottom: 0.25rem;
      }

      .stat-label {
        color: #6b7280;
        font-size: 0.7rem;
        font-weight: 500;
      }

      /* Locations List */
      .locations-panel {
        position: fixed;
        top: 80px;
        right: 1rem;
        z-index: 999;
        background: rgba(255, 255, 255, 0.95);
        backdrop-filter: blur(10px);
        border-radius: 12px;
        padding: 1rem;
        box-shadow: 0 4px 20px rgba(0, 0, 0, 0.15);
        border: 1px solid rgba(0, 0, 0, 0.1);
        max-width: 320px;
        max-height: calc(100vh - 100px);
        overflow-y: auto;
      }

      .locations-title {
        font-size: 0.9rem;
        font-weight: 600;
        color: #374151;
        margin-bottom: 0.75rem;
        display: flex;
        align-items: center;
        gap: 0.5rem;
      }

      .day-locations {
        margin-bottom: 1rem;
        background: #f8fafc;
        border-radius: 8px;
        padding: 0.75rem;
        border: 1px solid rgba(0, 0, 0, 0.05);
      }

      .day-title {
        font-size: 0.8rem;
        font-weight: 600;
        color: #1f2937;
        margin-bottom: 0.5rem;
      }

      .location-item {
        display: flex;
        align-items: center;
        gap: 0.5rem;
        padding: 0.5rem;
        background: white;
        border-radius: 6px;
        margin-bottom: 0.25rem;
        cursor: pointer;
        transition: all 0.2s;
        border: 1px solid rgba(0, 0, 0, 0.05);
      }

      .location-item:hover {
        background: #f1f5f9;
        transform: translateX(2px);
      }

      .location-marker {
        width: 12px;
        height: 12px;
        border-radius: 50%;
        flex-shrink: 0;
      }

      .location-info {
        flex: 1;
        min-width: 0;
      }

      .location-name {
        font-size: 0.75rem;
        font-weight: 500;
        color: #1f2937;
        line-height: 1.2;
      }

      .location-time {
        font-size: 0.65rem;
        color: #6b7280;
      }

      /* Mobile Responsive */
      @media (max-width: 768px) {
        .controls-panel {
          top: 70px;
          left: 0.5rem;
          right: 0.5rem;
          max-width: none;
          max-height: 35vh;
        }

        .locations-panel {
          display: none;
        }

        .header h1 {
          font-size: 1.25rem;
        }

        .day-controls {
          grid-template-columns: 1fr 1fr 1fr;
        }

        .control-section {
          margin-bottom: 1rem;
        }
      }

      /* Toggle Buttons */
      .toggle-btn {
        position: fixed;
        top: 50%;
        transform: translateY(-50%);
        z-index: 1001;
        background: rgba(255, 255, 255, 0.95);
        backdrop-filter: blur(10px);
        border: 1px solid rgba(0, 0, 0, 0.1);
        border-radius: 50%;
        width: 40px;
        height: 40px;
        display: flex;
        align-items: center;
        justify-content: center;
        cursor: pointer;
        font-size: 1.25rem;
        transition: all 0.2s;
        box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
      }

      .toggle-btn:hover {
        background: white;
        transform: translateY(-50%) scale(1.1);
      }

      .toggle-controls {
        left: 300px;
      }

      .toggle-locations {
        right: 340px;
      }

      @media (max-width: 768px) {
        .toggle-btn {
          display: none;
        }
      }
    </style>
  </head>

  <body>
    <!-- Header -->
    <header class="header">
      <h1>üó∫Ô∏è –ö–∞—Ä—Ç–∞ –ø—É—Ç–µ—à–µ—Å—Ç–≤–∏—è</h1>
      <a href="index.html" class="nav-link">‚Üê –ö –ø–ª–∞–Ω–∏—Ä–æ–≤—â–∏–∫—É</a>
    </header>

    <!-- Toggle Buttons -->
    <button
      class="toggle-btn toggle-controls"
      onclick="togglePanel('controls')"
      title="–ü–µ—Ä–µ–∫–ª—é—á–∏—Ç—å –ø–∞–Ω–µ–ª—å —É–ø—Ä–∞–≤–ª–µ–Ω–∏—è"
    >
      ‚öôÔ∏è
    </button>
    <button
      class="toggle-btn toggle-locations"
      onclick="togglePanel('locations')"
      title="–ü–µ—Ä–µ–∫–ª—é—á–∏—Ç—å —Å–ø–∏—Å–æ–∫ –ª–æ–∫–∞—Ü–∏–π"
    >
      üìç
    </button>

    <!-- Controls Panel -->
    <div class="controls-panel" id="controls-panel">
      <!-- Day Controls -->
      <div class="control-section">
        <div class="control-title">üìÖ –î–Ω–∏</div>
        <div class="day-controls">
          <button class="day-button active" onclick="showAllDays()">–í—Å–µ</button>
          <button class="day-button" onclick="showDay(1)">1</button>
          <button class="day-button" onclick="showDay(2)">2</button>
          <button class="day-button" onclick="showDay(3)">3</button>
          <button class="day-button" onclick="showDay(4)">4</button>
          <button class="day-button" onclick="showDay(5)">5</button>
          <button class="day-button" onclick="showDay(6)">6</button>
          <button class="day-button" onclick="showDay(7)">7</button>
        </div>
      </div>

      <!-- Filter Controls -->
      <div class="control-section">
        <div class="control-title">üîç –¢–∏–ø—ã</div>
        <div class="filter-controls">
          <button
            class="filter-btn btn-all active"
            onclick="filterLocations('all')"
          >
            –í—Å–µ —Ç–æ—á–∫–∏
          </button>
          <button
            class="filter-btn btn-hidden_gem"
            onclick="filterLocations('hidden_gem')"
          >
            üíé –ñ–µ–º—á—É–∂–∏–Ω—ã
          </button>
          <button
            class="filter-btn btn-activity"
            onclick="filterLocations('activity')"
          >
            üßó –ê–∫—Ç–∏–≤–Ω–æ—Å—Ç–∏
          </button>
          <button
            class="filter-btn btn-sightseeing"
            onclick="filterLocations('sightseeing')"
          >
            üèîÔ∏è –í–∏–¥—ã
          </button>
          <button
            class="filter-btn btn-accommodation"
            onclick="filterLocations('accommodation')"
          >
            üèïÔ∏è –ñ–∏–ª—å–µ
          </button>
          <button
            class="filter-btn btn-transport"
            onclick="filterLocations('transport')"
          >
            ‚õ¥Ô∏è –¢—Ä–∞–Ω—Å–ø–æ—Ä—Ç
          </button>
          <button
            class="filter-btn btn-shopping"
            onclick="filterLocations('shopping')"
          >
            üõí –ü–æ–∫—É–ø–∫–∏
          </button>
          <button
            class="filter-btn btn-logistics"
            onclick="filterLocations('logistics')"
          >
            üöê –õ–æ–≥–∏—Å—Ç–∏–∫–∞
          </button>
        </div>
      </div>

      <!-- Route Options -->
      <div class="control-section">
        <div class="control-title">üõ£Ô∏è –ú–∞—Ä—à—Ä—É—Ç—ã</div>
        <div class="route-options">
          <label class="route-option">
            <input
              type="checkbox"
              id="show-gem-routes"
              checked
              onchange="toggleGemRoutes()"
            />
            <span class="route-option-text">–ü–æ–∫–∞–∑–∞—Ç—å –¥–µ—Ç—É—Ä—ã –∫ –∂–µ–º—á—É–∂–∏–Ω–∞–º</span>
          </label>
        </div>
      </div>

      <!-- Statistics -->
      <div class="control-section">
        <div class="control-title">üìä –°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞</div>
        <div class="stats-section">
          <div class="stat-card">
            <div class="stat-number" id="total-locations">-</div>
            <div class="stat-label">–¢–æ—á–µ–∫</div>
          </div>
          <div class="stat-card">
            <div class="stat-number" id="total-distance">-</div>
            <div class="stat-label">–ö–º</div>
          </div>
          <div class="stat-card">
            <div class="stat-number" id="hidden-gems">-</div>
            <div class="stat-label">–ñ–µ–º—á—É–∂–∏–Ω</div>
          </div>
          <div class="stat-card">
            <div class="stat-number">7</div>
            <div class="stat-label">–î–Ω–µ–π</div>
          </div>
        </div>
      </div>
    </div>

    <!-- Locations Panel -->
    <div class="locations-panel" id="locations-panel">
      <div class="locations-title">üìç –õ–æ–∫–∞—Ü–∏–∏</div>
      <div id="locations-container"></div>
    </div>

    <!-- Map Container -->
    <div class="map-container">
      <div id="map"></div>
    </div>

    <script src="config.js"></script>
    <script src="script.js"></script>
    <script>
      let map;
      let markers = [];
      let routeLines = [];
      let gemRoutes = [];
      let infoWindow;
      let directionsService;
      let directionsRenderers = [];
      let gemDirectionsRenderers = [];
      let currentFilter = "all";
      let currentDay = "all";
      let showGemRoutes = true;

      // API optimization - cache and throttling
      let directionsCache = new Map();
      let pendingRequests = 0;
      let apiRequestCount = 0;
      let cacheHits = 0;
      const MAX_CONCURRENT_REQUESTS = 2;
      const REQUEST_DELAY = 100; // ms between requests
      const CACHE_EXPIRY = 24 * 60 * 60 * 1000; // 24 hours

      // Color mapping for location types
      const typeColors = {
        logistics: "#8B5CF6",
        shopping: "#F59E0B",
        accommodation: "#10B981",
        activity: "#EF4444",
        sightseeing: "#3B82F6",
        transport: "#6B7280",
        hidden_gem: "#EC4899",
        optional: "#F97316",
      };

      function getLocationTypeEmoji(type) {
        const emojis = {
          logistics: "üöê",
          shopping: "üõí",
          accommodation: "üèïÔ∏è",
          activity: "üßó",
          sightseeing: "üèîÔ∏è",
          transport: "‚õ¥Ô∏è",
          optional: "‚≠ê",
          hidden_gem: "üíé",
        };
        return emojis[type] || "üìç";
      }

      // Initialize Google Map
      function initMap() {
        map = new google.maps.Map(document.getElementById("map"), {
          zoom: 6,
          center: { lat: 61.5, lng: 8.0 },
          mapTypeId: google.maps.MapTypeId.ROADMAP,
          styles: [
            {
              featureType: "poi",
              elementType: "labels",
              stylers: [{ visibility: "off" }],
            },
            {
              featureType: "water",
              elementType: "geometry",
              stylers: [{ color: "#a2daf2" }],
            },
            {
              featureType: "landscape",
              elementType: "geometry.fill",
              stylers: [{ color: "#f5f5f2" }],
            },
          ],
        });

        infoWindow = new google.maps.InfoWindow();
        directionsService = new google.maps.DirectionsService();

        // Load cached directions
        loadCache();

        // Check if tripData is available before proceeding
        if (typeof tripData !== "undefined") {
          calculateStats();
          initializeMapWithoutZoom();
          renderLocationList();
        } else {
          console.error("tripData is not defined - check script.js loading");
        }

        // Log API usage stats after initialization
        setTimeout(() => {
          console.log(
            `API Usage Stats: ${apiRequestCount} requests, ${cacheHits} cache hits, ${directionsCache.size} cached routes`
          );
        }, 5000);
      }

      function clearMap() {
        markers.forEach((item) => item.marker.setMap(null));
        routeLines.forEach((line) => line.setMap(null));
        gemRoutes.forEach((line) => line.setMap(null));
        directionsRenderers.forEach((renderer) => renderer.setMap(null));
        gemDirectionsRenderers.forEach((renderer) => renderer.setMap(null));
        markers = [];
        routeLines = [];
        gemRoutes = [];
        directionsRenderers = [];
        gemDirectionsRenderers = [];
      }

      function addLocationMarker(location, dayNum) {
        if (!location.coordinates) return;

        const [lat, lng] = location.coordinates;
        const color = typeColors[location.type] || "#3B82F6";
        const emoji = getLocationTypeEmoji(location.type);

        const markerIcon = {
          path: google.maps.SymbolPath.CIRCLE,
          scale: 12,
          fillColor: color,
          fillOpacity: 0.9,
          strokeColor: "white",
          strokeWeight: 3,
        };

        const marker = new google.maps.Marker({
          position: { lat: lat, lng: lng },
          map: map,
          title: location.name,
          icon: markerIcon,
        });

        const contentString = `
          <div style="max-width: 300px; padding: 12px; font-family: system-ui, sans-serif;">
            <h3 style="margin: 0 0 8px 0; font-size: 16px; font-weight: bold; color: #1f2937;">${emoji} ${
          location.name
        }</h3>
            <p style="margin: 0 0 8px 0; color: #6b7280; font-size: 13px; font-weight: 500;">–î–µ–Ω—å ${dayNum} ‚Ä¢ ${
          location.time
        }</p>
            <p style="margin: 0 0 12px 0; font-size: 13px; line-height: 1.4; color: #374151;">${
              location.description
            }</p>
            ${
              location.notes
                ? `<div style="margin: 0 0 12px 0; padding: 8px; background: #fef3c7; border-radius: 6px; border-left: 3px solid #f59e0b;"><p style="margin: 0; font-size: 11px; color: #92400e; font-weight: 500;">üí° ${location.notes}</p></div>`
                : ""
            }
            <div style="display: flex; gap: 6px; flex-wrap: wrap;">
              ${
                location.maps
                  ? `<a href="${location.maps}" target="_blank" style="background: #3b82f6; color: white; padding: 6px 12px; border-radius: 4px; text-decoration: none; font-size: 11px; font-weight: 600;">üó∫Ô∏è Maps</a>`
                  : ""
              }
              <button onclick="focusOnLocation(${lat}, ${lng})" style="background: #10b981; color: white; padding: 6px 12px; border: none; border-radius: 4px; cursor: pointer; font-size: 11px; font-weight: 600;">üéØ –¶–µ–Ω—Ç—Ä</button>
            </div>
          </div>
        `;

        // Hover effects with animation-like behavior
        marker.addListener("mouseover", () => {
          const hoveredIcon = {
            ...markerIcon,
            scale: 18, // –ó–∞–º–µ—Ç–Ω–æ —É–≤–µ–ª–∏—á–∏–≤–∞–µ–º —Ä–∞–∑–º–µ—Ä
            strokeWeight: 5, // –£—Ç–æ–ª—â–∞–µ–º –æ–±–≤–æ–¥–∫—É
            fillOpacity: 1.0, // –î–µ–ª–∞–µ–º –ø–æ–ª–Ω–æ—Å—Ç—å—é –Ω–µ–ø—Ä–æ–∑—Ä–∞—á–Ω—ã–º
            strokeColor: "#FFD700", // –ó–æ–ª–æ—Ç–∞—è –æ–±–≤–æ–¥–∫–∞ –ø—Ä–∏ hover
          };
          marker.setIcon(hoveredIcon);

          // –î–æ–±–∞–≤–ª—è–µ–º –Ω–µ–±–æ–ª—å—à—É—é –∞–Ω–∏–º–∞—Ü–∏—é –ø–æ–¥–ø—Ä—ã–≥–∏–≤–∞–Ω–∏—è
          marker.setAnimation(google.maps.Animation.BOUNCE);
          setTimeout(() => {
            marker.setAnimation(null);
          }, 200); // –û—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º –∞–Ω–∏–º–∞—Ü–∏—é —á–µ—Ä–µ–∑ 200–º—Å
        });

        marker.addListener("mouseout", () => {
          marker.setIcon(markerIcon); // –í–æ–∑–≤—Ä–∞—â–∞–µ–º –∏—Å—Ö–æ–¥–Ω—ã–π —Ä–∞–∑–º–µ—Ä –∏ —Ü–≤–µ—Ç
        });

        marker.addListener("click", () => {
          infoWindow.setContent(contentString);
          infoWindow.open(map, marker);
        });

        markers.push({ marker, location, day: dayNum, type: location.type });
      }

      function addRouteLines(dayData) {
        console.log(`Building routes for Day ${dayData.day}:`);
        console.log(
          "All locations:",
          dayData.locations.map((l) => ({ name: l.name, type: l.type }))
        );

        // Filter out hidden gems and optional locations from main route
        const mainRouteLocations = dayData.locations.filter(
          (location) =>
            location.type !== "hidden_gem" && location.type !== "optional"
        );

        console.log(
          "Main route locations:",
          mainRouteLocations.map((l) => ({ name: l.name, type: l.type }))
        );

        const waypoints = [];

        // Add main route locations only (skip day coordinates as they might be end point)
        mainRouteLocations.forEach((location) => {
          if (location.coordinates) {
            waypoints.push({
              lat: location.coordinates[0],
              lng: location.coordinates[1],
            });
          }
        });

        // If we don't have enough waypoints, but day has coordinates, use them as start
        if (waypoints.length < 2 && dayData.coordinates) {
          waypoints.unshift({
            lat: dayData.coordinates[0],
            lng: dayData.coordinates[1],
          });
          console.log(
            "Added day coordinates as start due to insufficient waypoints:",
            dayData.coordinates
          );
        }

        console.log("Total waypoints for main route:", waypoints.length);
        console.log("Waypoints:", waypoints);

        // Build driving route if we have enough points
        if (waypoints.length > 1) {
          buildDrivingRoute(waypoints);
        } else {
          console.warn(
            `Not enough waypoints for Day ${dayData.day}: ${waypoints.length}`
          );
        }

        // Add dashed lines for hidden gems and optional locations if enabled
        if (showGemRoutes) {
          addGemRoutes(dayData, mainRouteLocations);
        }
      }

      function createCacheKey(request) {
        const waypoints = [request.origin];
        if (request.waypoints) {
          waypoints.push(...request.waypoints.map((wp) => wp.location));
        }
        waypoints.push(request.destination);

        return waypoints
          .map((point) => `${point.lat.toFixed(4)},${point.lng.toFixed(4)}`)
          .join("|");
      }

      function loadCache() {
        try {
          const cached = localStorage.getItem("directionsCache");
          if (cached) {
            const cacheData = JSON.parse(cached);
            // Check if cache is still valid
            const now = Date.now();
            Object.entries(cacheData).forEach(([key, value]) => {
              if (now - value.timestamp < CACHE_EXPIRY) {
                directionsCache.set(key, value.result);
              }
            });
          }
        } catch (e) {
          console.warn("Failed to load directions cache:", e);
        }
      }

      function saveCache() {
        try {
          const cacheData = {};
          const now = Date.now();
          directionsCache.forEach((result, key) => {
            cacheData[key] = {
              result: result,
              timestamp: now,
            };
          });
          localStorage.setItem("directionsCache", JSON.stringify(cacheData));
        } catch (e) {
          console.warn("Failed to save directions cache:", e);
        }
      }

      function throttledDirectionsRequest(
        request,
        callback,
        isGemRoute = false
      ) {
        const cacheKey = createCacheKey(request);

        // Check cache first
        if (directionsCache.has(cacheKey)) {
          const cachedResult = directionsCache.get(cacheKey);
          cacheHits++;
          setTimeout(() => callback(cachedResult, "OK"), 10);
          return;
        }

        // Throttle requests
        if (pendingRequests >= MAX_CONCURRENT_REQUESTS) {
          setTimeout(
            () => throttledDirectionsRequest(request, callback, isGemRoute),
            REQUEST_DELAY
          );
          return;
        }

        pendingRequests++;
        apiRequestCount++;

        setTimeout(() => {
          directionsService.route(request, (result, status) => {
            pendingRequests--;

            if (status === "OK") {
              // Cache successful result
              directionsCache.set(cacheKey, result);
              saveCache();
            }

            callback(result, status, isGemRoute);
          });
        }, REQUEST_DELAY * pendingRequests);
      }

      function buildDrivingRoute(waypoints) {
        if (waypoints.length < 2) return;

        // Google Directions API allows max 25 waypoints total (23 intermediate + origin + destination)
        const MAX_WAYPOINTS = 23;

        if (waypoints.length <= MAX_WAYPOINTS + 2) {
          // Build single route
          buildSingleDrivingRoute(waypoints);
        } else {
          // Split into multiple segments
          console.log(
            "Splitting long route into segments:",
            waypoints.length,
            "waypoints"
          );
          buildSegmentedDrivingRoute(waypoints);
        }
      }

      function buildSingleDrivingRoute(waypoints) {
        const start = waypoints[0];
        const end = waypoints[waypoints.length - 1];
        const intermediateWaypoints = waypoints.slice(1, -1).map((point) => ({
          location: point,
          stopover: true,
        }));

        const request = {
          origin: start,
          destination: end,
          waypoints: intermediateWaypoints,
          travelMode: google.maps.TravelMode.DRIVING,
          optimizeWaypoints: false, // Keep original order
        };

        throttledDirectionsRequest(request, (result, status) => {
          if (status === "OK") {
            const directionsRenderer = new google.maps.DirectionsRenderer({
              suppressMarkers: true, // We have our own markers
              polylineOptions: {
                strokeColor: "#3B82F6",
                strokeOpacity: 0.8,
                strokeWeight: 4,
              },
            });

            directionsRenderer.setDirections(result);
            directionsRenderer.setMap(map);
            directionsRenderers.push(directionsRenderer);
            console.log(
              "Driving route built successfully with",
              waypoints.length,
              "waypoints"
            );
          } else {
            console.warn(
              "Directions request failed due to " + status + " for route with",
              waypoints.length,
              "waypoints"
            );
            console.log("Failed waypoints:", waypoints);

            // Try alternative strategies based on error type
            if (status === "ZERO_RESULTS" && waypoints.length > 3) {
              console.log("Trying segmented approach due to ZERO_RESULTS");
              buildSegmentedDrivingRoute(waypoints);
            } else if (status === "MAX_WAYPOINTS_EXCEEDED") {
              console.log(
                "Forcing segmented approach due to too many waypoints"
              );
              buildSegmentedDrivingRoute(waypoints);
            } else {
              // Fallback to straight lines if directions fail
              buildFallbackRoute(waypoints);
            }
          }
        });
      }

      function buildSegmentedDrivingRoute(waypoints) {
        const MAX_SEGMENT_SIZE = 8; // Smaller segments for better reliability

        for (let i = 0; i < waypoints.length - 1; i += MAX_SEGMENT_SIZE - 1) {
          const segmentEnd = Math.min(i + MAX_SEGMENT_SIZE, waypoints.length);
          const segmentWaypoints = waypoints.slice(i, segmentEnd);

          if (segmentWaypoints.length >= 2) {
            buildSingleDrivingRoute(segmentWaypoints);
          }
        }
      }

      function buildFallbackRoute(waypoints) {
        if (waypoints.length > 1) {
          const routeLine = new google.maps.Polyline({
            path: waypoints,
            geodesic: true,
            strokeColor: "#3B82F6",
            strokeOpacity: 0.8,
            strokeWeight: 4,
          });

          routeLine.setMap(map);
          routeLines.push(routeLine);
        }
      }

      function addGemRoutes(dayData, mainRouteLocations) {
        const gemLocations = dayData.locations.filter(
          (location) =>
            location.type === "hidden_gem" || location.type === "optional"
        );

        gemLocations.forEach((gemLocation) => {
          if (!gemLocation.coordinates) return;

          // Find the closest main route location
          let closestLocation = null;
          let minDistance = Infinity;

          const allMainCoords = [];
          if (dayData.coordinates) {
            allMainCoords.push({
              lat: dayData.coordinates[0],
              lng: dayData.coordinates[1],
            });
          }
          mainRouteLocations.forEach((loc) => {
            if (loc.coordinates) {
              allMainCoords.push({
                lat: loc.coordinates[0],
                lng: loc.coordinates[1],
              });
            }
          });

          allMainCoords.forEach((coord) => {
            const distance = calculateDistance(
              gemLocation.coordinates[0],
              gemLocation.coordinates[1],
              coord.lat,
              coord.lng
            );
            if (distance < minDistance) {
              minDistance = distance;
              closestLocation = coord;
            }
          });

          // Build driving route to closest main route point
          // Only use API for routes longer than 5km to save quota
          if (closestLocation) {
            if (minDistance > 5) {
              buildGemDrivingRoute(
                closestLocation,
                {
                  lat: gemLocation.coordinates[0],
                  lng: gemLocation.coordinates[1],
                },
                gemLocation.type
              );
            } else {
              // Use fallback for short distances
              buildFallbackGemRoute(
                closestLocation,
                {
                  lat: gemLocation.coordinates[0],
                  lng: gemLocation.coordinates[1],
                },
                gemLocation.type
              );
            }
          }
        });
      }

      function buildGemDrivingRoute(fromPoint, toPoint, gemType) {
        const request = {
          origin: fromPoint,
          destination: toPoint,
          travelMode: google.maps.TravelMode.DRIVING,
        };

        throttledDirectionsRequest(
          request,
          (result, status) => {
            if (status === "OK") {
              const directionsRenderer = new google.maps.DirectionsRenderer({
                suppressMarkers: true, // We have our own markers
                polylineOptions: {
                  strokeColor: gemType === "hidden_gem" ? "#EC4899" : "#F97316",
                  strokeOpacity: 0.6,
                  strokeWeight: 3,
                  strokePattern: [10, 5], // Dashed line for gem routes
                },
              });

              directionsRenderer.setDirections(result);
              directionsRenderer.setMap(map);
              gemDirectionsRenderers.push(directionsRenderer);
            } else {
              console.warn("Gem directions request failed due to " + status);
              // Fallback to dashed straight line if directions fail
              buildFallbackGemRoute(fromPoint, toPoint, gemType);
            }
          },
          true
        );
      }

      function buildFallbackGemRoute(fromPoint, toPoint, gemType) {
        const gemLine = new google.maps.Polyline({
          path: [fromPoint, toPoint],
          geodesic: true,
          strokeColor: gemType === "hidden_gem" ? "#EC4899" : "#F97316",
          strokeOpacity: 0.6,
          strokeWeight: 3,
          icons: [
            {
              icon: { path: "M 0,-1 0,1", strokeOpacity: 1, scale: 4 },
              offset: "0",
              repeat: "20px",
            },
          ],
        });

        gemLine.setMap(map);
        gemRoutes.push(gemLine);
      }

      function calculateDistance(lat1, lng1, lat2, lng2) {
        const R = 6371; // Earth's radius in km
        const dLat = ((lat2 - lat1) * Math.PI) / 180;
        const dLng = ((lng2 - lng1) * Math.PI) / 180;
        const a =
          Math.sin(dLat / 2) * Math.sin(dLat / 2) +
          Math.cos((lat1 * Math.PI) / 180) *
            Math.cos((lat2 * Math.PI) / 180) *
            Math.sin(dLng / 2) *
            Math.sin(dLng / 2);
        const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
        return R * c;
      }

      function showDay(dayNum) {
        currentDay = dayNum;
        clearMap();

        const dayData = tripData.days.find((day) => day.day === dayNum);
        if (!dayData) return;

        dayData.locations.forEach((location) => {
          if (currentFilter === "all" || location.type === currentFilter) {
            addLocationMarker(location, dayNum);
          }
        });

        addRouteLines(dayData);

        // Update active day button
        document
          .querySelectorAll(".day-button")
          .forEach((btn) => btn.classList.remove("active"));
        const targetButton = document.querySelector(
          `[onclick*="showDay(${dayNum})"]`
        );
        if (targetButton) {
          targetButton.classList.add("active");
        } else {
          // Fallback: find button by text content
          const buttons = document.querySelectorAll(".day-button");
          buttons.forEach((btn) => {
            if (btn.textContent.trim() === dayNum.toString()) {
              btn.classList.add("active");
            }
          });
        }

        renderLocationList();
      }

      function showAllDays() {
        currentDay = "all";
        clearMap();

        tripData.days.forEach((day) => {
          day.locations.forEach((location) => {
            if (currentFilter === "all" || location.type === currentFilter) {
              addLocationMarker(location, day.day);
            }
          });
          addRouteLines(day);
        });

        // Update active day button
        document
          .querySelectorAll(".day-button")
          .forEach((btn) => btn.classList.remove("active"));
        const allDaysButton = document.querySelector(
          '[onclick*="showAllDays"]'
        );
        if (allDaysButton) {
          allDaysButton.classList.add("active");
        } else {
          // Fallback: find button with "–í—Å–µ" text
          const buttons = document.querySelectorAll(".day-button");
          buttons.forEach((btn) => {
            if (btn.textContent.trim() === "–í—Å–µ") {
              btn.classList.add("active");
            }
          });
        }

        renderLocationList();
      }

      function filterLocations(type) {
        currentFilter = type;

        if (currentDay === "all") {
          showAllDays();
        } else {
          showDay(currentDay);
        }

        // Update active filter button
        document
          .querySelectorAll(".filter-btn")
          .forEach((btn) => btn.classList.remove("active"));
        const targetButton = document.querySelector(
          `[onclick*="filterLocations('${type}')"]`
        );
        if (targetButton) {
          targetButton.classList.add("active");
        } else {
          // Fallback: find button by class
          const fallbackButton = document.querySelector(`.btn-${type}`);
          if (fallbackButton) {
            fallbackButton.classList.add("active");
          }
        }
      }

      function initializeMapWithoutZoom() {
        // –ü–æ–∫–∞–∑—ã–≤–∞–µ–º –≤—Å–µ –¥–Ω–∏ –Ω–æ –±–µ–∑ –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–æ–≥–æ –ø–æ–∑–∏—Ü–∏–æ–Ω–∏—Ä–æ–≤–∞–Ω–∏—è
        currentDay = "all";
        clearMap();

        tripData.days.forEach((day) => {
          day.locations.forEach((location) => {
            if (currentFilter === "all" || location.type === currentFilter) {
              addLocationMarker(location, day.day);
            }
          });
          addRouteLines(day);
        });

        // Update active day button without repositioning map
        document
          .querySelectorAll(".day-button")
          .forEach((btn) => btn.classList.remove("active"));
        const allDaysButton = document.querySelector(
          '[onclick*="showAllDays"]'
        );
        if (allDaysButton) {
          allDaysButton.classList.add("active");
        } else {
          const buttons = document.querySelectorAll(".day-button");
          buttons.forEach((btn) => {
            if (btn.textContent.trim() === "–í—Å–µ") {
              btn.classList.add("active");
            }
          });
        }
      }

      function fitMapToMarkers() {
        // –£–±–∏—Ä–∞–µ–º –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–æ–µ –∏–∑–º–µ–Ω–µ–Ω–∏–µ –∑—É–º–∞ –∏ –ø–æ–∑–∏—Ü–∏–∏
        // –ö–∞—Ä—Ç–∞ –æ—Å—Ç–∞–µ—Ç—Å—è –≤ —Ç–µ–∫—É—â–µ–º –ø–æ–ª–æ–∂–µ–Ω–∏–∏
      }

      function clearOldCache() {
        try {
          const cached = localStorage.getItem("directionsCache");
          if (cached) {
            const cacheData = JSON.parse(cached);
            const now = Date.now();
            const validCacheData = {};

            Object.entries(cacheData).forEach(([key, value]) => {
              if (now - value.timestamp < CACHE_EXPIRY) {
                validCacheData[key] = value;
              }
            });

            localStorage.setItem(
              "directionsCache",
              JSON.stringify(validCacheData)
            );
            console.log("Cleaned old cache entries");
          }
        } catch (e) {
          console.warn("Failed to clean cache:", e);
        }
      }

      function calculateStats() {
        let totalLocations = 0;
        let hiddenGems = 0;
        let totalDistance = 0;

        tripData.days.forEach((day) => {
          totalLocations += day.locations.length;
          hiddenGems += day.locations.filter(
            (loc) => loc.type === "hidden_gem"
          ).length;

          const distanceMatch = day.distance.match(/(\d+)/);
          if (distanceMatch) {
            totalDistance += parseInt(distanceMatch[1]);
          }
        });

        document.getElementById("total-locations").textContent = totalLocations;
        document.getElementById("hidden-gems").textContent = hiddenGems;
        document.getElementById("total-distance").textContent = totalDistance;

        // Clean old cache entries on stats calculation
        clearOldCache();
      }

      function renderLocationList() {
        const container = document.getElementById("locations-container");
        container.innerHTML = "";

        const filteredMarkers = markers.filter(
          (item) =>
            (currentFilter === "all" || item.type === currentFilter) &&
            (currentDay === "all" || item.day === currentDay)
        );

        const locationsByDay = {};
        filteredMarkers.forEach((item) => {
          if (!locationsByDay[item.day]) {
            locationsByDay[item.day] = [];
          }
          locationsByDay[item.day].push(item);
        });

        Object.keys(locationsByDay)
          .sort((a, b) => parseInt(a) - parseInt(b))
          .forEach((day) => {
            const dayData = tripData.days.find((d) => d.day == day);
            const dayDiv = document.createElement("div");
            dayDiv.className = "day-locations";

            dayDiv.innerHTML = `
              <div class="day-title">–î–µ–Ω—å ${day}: ${dayData.title}</div>
              ${locationsByDay[day]
                .map(
                  (item) => `
                <div class="location-item" 
                     onclick="focusOnLocationAndOpen(${
                       item.location.coordinates[0]
                     }, ${item.location.coordinates[1]})"
                     onmouseover="highlightMarker(${
                       item.location.coordinates[0]
                     }, ${item.location.coordinates[1]}, true)"
                     onmouseout="highlightMarker(${
                       item.location.coordinates[0]
                     }, ${item.location.coordinates[1]}, false)">
                  <div class="location-marker" style="background-color: ${
                    typeColors[item.type]
                  }"></div>
                  <div class="location-info">
                    <div class="location-name">${getLocationTypeEmoji(
                      item.type
                    )} ${item.location.name}</div>
                    <div class="location-time">${item.location.time}</div>
                  </div>
                </div>
              `
                )
                .join("")}
            `;

            container.appendChild(dayDiv);
          });
      }

      function focusOnLocation(lat, lng) {
        map.setCenter({ lat: lat, lng: lng });
        // –£–±–∏—Ä–∞–µ–º –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏–π –∑—É–º
      }

      function focusOnLocationAndOpen(lat, lng) {
        map.setCenter({ lat: lat, lng: lng });
        // –£–±–∏—Ä–∞–µ–º –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏–π –∑—É–º

        const markerItem = markers.find(
          (item) =>
            item.location.coordinates[0] === lat &&
            item.location.coordinates[1] === lng
        );

        if (markerItem) {
          google.maps.event.trigger(markerItem.marker, "click");
        }
      }

      function highlightMarker(lat, lng, highlight) {
        const markerItem = markers.find(
          (item) =>
            item.location.coordinates[0] === lat &&
            item.location.coordinates[1] === lng
        );

        if (markerItem) {
          if (highlight) {
            // Trigger mouseover effect
            google.maps.event.trigger(markerItem.marker, "mouseover");
          } else {
            // Trigger mouseout effect
            google.maps.event.trigger(markerItem.marker, "mouseout");
          }
        }
      }

      function togglePanel(panelType) {
        const panel = document.getElementById(`${panelType}-panel`);
        panel.style.display = panel.style.display === "none" ? "block" : "none";
      }

      function toggleGemRoutes() {
        showGemRoutes = document.getElementById("show-gem-routes").checked;

        // Hide/show existing gem routes (polylines)
        gemRoutes.forEach((line) => {
          line.setMap(showGemRoutes ? map : null);
        });

        // Hide/show gem directions renderers
        gemDirectionsRenderers.forEach((renderer) => {
          renderer.setMap(showGemRoutes ? map : null);
        });

        // If showing gem routes and there are none, redraw the current view
        if (
          showGemRoutes &&
          gemRoutes.length === 0 &&
          gemDirectionsRenderers.length === 0
        ) {
          if (currentDay === "all") {
            showAllDays();
          } else {
            showDay(currentDay);
          }
        }
      }

      // Initialize when DOM is ready
      document.addEventListener("DOMContentLoaded", function () {
        // Add event listeners to buttons if onclick doesn't work
        document.querySelectorAll(".day-button").forEach((button) => {
          const onclick = button.getAttribute("onclick");
          if (onclick) {
            button.addEventListener("click", function (e) {
              e.preventDefault();
              if (onclick.includes("showAllDays")) {
                showAllDays();
              } else {
                const dayMatch = onclick.match(/showDay\((\d+)\)/);
                if (dayMatch) {
                  showDay(parseInt(dayMatch[1]));
                }
              }
            });
          }
        });

        document.querySelectorAll(".filter-btn").forEach((button) => {
          const onclick = button.getAttribute("onclick");
          if (onclick) {
            button.addEventListener("click", function (e) {
              e.preventDefault();
              const filterMatch = onclick.match(/filterLocations\('(\w+)'\)/);
              if (filterMatch) {
                filterLocations(filterMatch[1]);
              }
            });
          }
        });
      });

      // Make functions globally available
      window.initMap = initMap;
      window.showDay = showDay;
      window.showAllDays = showAllDays;
      window.filterLocations = filterLocations;
      window.focusOnLocation = focusOnLocation;
      window.focusOnLocationAndOpen = focusOnLocationAndOpen;
      window.highlightMarker = highlightMarker;
      window.togglePanel = togglePanel;
      window.toggleGemRoutes = toggleGemRoutes;
    </script>

    <!-- Google Maps API - Dynamic Loading -->
    <script>
      // Load Google Maps API dynamically using config
      function loadGoogleMapsAPI() {
        if (typeof CONFIG === 'undefined') {
          console.error('CONFIG –Ω–µ –Ω–∞–π–¥–µ–Ω! –£–±–µ–¥–∏—Ç–µ—Å—å, —á—Ç–æ config.js –∑–∞–≥—Ä—É–∂–µ–Ω.');
          document.body.innerHTML = '<div style="padding: 20px; text-align: center; font-family: system-ui;"><h2>‚ö†Ô∏è –û—à–∏–±–∫–∞ –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏–∏</h2><p>–§–∞–π–ª config.js –Ω–µ –Ω–∞–π–¥–µ–Ω –∏–ª–∏ –Ω–µ —Å–æ–¥–µ—Ä–∂–∏—Ç API –∫–ª—é—á.</p><p>–°–ª–µ–¥—É–π—Ç–µ –∏–Ω—Å—Ç—Ä—É–∫—Ü–∏—è–º –≤ README.md –¥–ª—è –Ω–∞—Å—Ç—Ä–æ–π–∫–∏.</p></div>';
          return;
        }
        
        if (!CONFIG.GOOGLE_MAPS_API_KEY || CONFIG.GOOGLE_MAPS_API_KEY === 'YOUR_GOOGLE_MAPS_API_KEY_HERE') {
          console.error('Google Maps API –∫–ª—é—á –Ω–µ –Ω–∞—Å—Ç—Ä–æ–µ–Ω!');
          document.body.innerHTML = '<div style="padding: 20px; text-align: center; font-family: system-ui;"><h2>üîë –¢—Ä–µ–±—É–µ—Ç—Å—è API –∫–ª—é—á</h2><p>–ù–∞—Å—Ç—Ä–æ–π—Ç–µ Google Maps API –∫–ª—é—á –≤ —Ñ–∞–π–ª–µ config.js</p><p>–°–ª–µ–¥—É–π—Ç–µ –∏–Ω—Å—Ç—Ä—É–∫—Ü–∏—è–º –≤ README.md</p></div>';
          return;
        }

        const script = document.createElement('script');
        script.async = true;
        script.defer = true;
        script.src = `https://maps.googleapis.com/maps/api/js?key=${CONFIG.GOOGLE_MAPS_API_KEY}&callback=initMap`;
        script.onerror = function() {
          console.error('–û—à–∏–±–∫–∞ –∑–∞–≥—Ä—É–∑–∫–∏ Google Maps API');
          document.body.innerHTML = '<div style="padding: 20px; text-align: center; font-family: system-ui;"><h2>üåê –û—à–∏–±–∫–∞ –∑–∞–≥—Ä—É–∑–∫–∏ –∫–∞—Ä—Ç—ã</h2><p>–ù–µ —É–¥–∞–ª–æ—Å—å –∑–∞–≥—Ä—É–∑–∏—Ç—å Google Maps API.</p><p>–ü—Ä–æ–≤–µ—Ä—å—Ç–µ API –∫–ª—é—á –∏ –ø–æ–¥–∫–ª—é—á–µ–Ω–∏–µ –∫ –∏–Ω—Ç–µ—Ä–Ω–µ—Ç—É.</p></div>';
        };
        document.head.appendChild(script);
      }

      // Load API after DOM is ready
      if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', loadGoogleMapsAPI);
      } else {
        loadGoogleMapsAPI();
      }
    </script>
  </body>
</html>
